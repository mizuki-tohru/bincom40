<!--# name-->
#bincom binary serial monitor ver40

<!--## Overview-->
## binary serial monitor plus Lua / plus device control

　バイナリモニタbincom40は、シリアルポート入出力をスクリプト言語Luaで制御可能な
プログラムです。これによりシリアル接続デバイスのエミュレートや、試験の自動化
などが可能です。また入出力を手動操作可能であり、これらはバイナリ表示で確認可能
ですログラムです。また同時に、ASCIIキャラクタに関しては同時にキャラクタ表示を
確認することが可能です。
　本プログラムはシリアルインタフェイス、HID USB、LANインタフェイスを持つ計測器
等のうち、デバイス定義ファイルに定義が存在するものについて、Luaスクリプト上から
操作が可能です。特にOWON HDS2102Sハンディオシロに関してはデータ及び画面取得の
機能をLauスクリプトから利用可能です。
　シリアルポートは合計5つまで同時に接続可能です。うちConfig.txtで定義した
ポートのみ手動操作が可能です。

<!--## Requirement-->
## Requirement
-MS Windows

## Features
## 1.1：手動操作について
　本プログラムは、別ファイルで定義したデータ列を簡単な操作で送信することが
できます。本プログラムは、キーボードから入力したキャラクタを送信することが
できます。ただ、リターン以外の入力はまずバッファに溜められ、即座に出力される
事はありません。入力したキャラクタは画面下部に表示されます。バッファに溜められた
キャラクタは、リターンキー入力で一気に送信されます。
　リターンキーを連続して入力すると、以前に入力したデータが繰り返し送信され
ます。送信されたデータ・キャラクタはすべて画面下部に表示されます。この表示は、
キーボードからの入力のみキャラクタで、その他は、繰り返し送信の出力も含めて
16進表記で表示されます。
　本バージョンでは、CTS,RTC,DTR,DSRといった信号をコントロールする設定
オプションが用意されています。また、シリアルデータ終端にCRやLFを自動付与、
除去するためのオプションが用意されています。

### 1.2:スクリプト操作について
　本プログラムはConfig.txtで定義されたLuaスクリプトファイルを起動時に読み込み、
これに従って動作します。Luaスクリプトは後述する関数によって機能が拡張されて
います。また、起動時に一度だけ実行される定義済関数Startup()と、定義インターバル
毎に実行される定義済み関数Loop()が用意されています。
　拡張関数mkframeはConfig.txtに定義された固定テレメトリフレーム定義ファイルに
基づいてバイナリテレメトリを生成します。
　Config.txtに定義された内部レジスタ定義ファイル内で定義されたレジスタメモリ
空間をLuaスクリプトから拡張関数を用いて自由にアクセスすることができます。
　これら機能によって、シリアルインタフェイスを持つデバイスのエミュレーションが
容易になります。

## Setting
## 2:構成
　本プログラムは実行ファイルbincom40.exeと、設定ファイルconfig.txtの二つが
最低限の動作に必要です。
　送信データ定義ファイルはconfig.txtに記述したファイル名のものを起動時に読み
込み動作します。もしconfig.txtに定義がなければ、command.txtというファイルを
探し読み込もうとします。
　Luaスクリプトファイルはconfig.txtに記述したファイル名のものを起動時に読み
込み動作します。ファイルが無い場合はLuaの動作はありません。もしconfig.txtに
定義がなければ、script.luaというファイルを探し読み込もうとします。もし無ければ
Luaは動作しません。
　レジスタ定義ファイルはconfig.txtに記述したファイル名のものを起動時に読み込み
動作します。これはLuaスクリプトが利用できる仮想レジスタ定義のファイルです。
もしconfig.txtに定義がなければ、reg.txtというファイルを探し読み込もうとします。
もし無ければLuaは仮想レジスタを利用できません。
　計測器定義ファイルはconfig.txtに記述したファイル名のものを起動時に読み込み
ます。計測器定義ファイルは更に各デバイスのコマンド定義ファイルを記述しています。

　配布時のファイル構成は以下のようになります。
bincom40.exe
config.txt
readme.txt
script.lua
command.txt
tlm.txt
reg.txt
device_config.txt
DM7560_Config.txt
PR100_Config.txt
KX100L_Config.txt
PAT80_Config.txt
HDS2102S_Config.txt
SPE6102_Config.txt
DP100_Config.txt
src.zip

　readme.txtは本文書です。src.zipはソースコード一式です。
　本プログラムはMicrosoft VisualC++2022 ExpressEditionでコンパイル可能です。


## Conig
## 3:設定
　本プログラム起動前に、Config.txtでシリアルポートのうち1つのポートと
ボーレートの設定が可能です。また、プログラム動作中の任意のタイミングで、
このポートのボーレートを変更することができます。
　プログラム起動前の設定は、bincom実行ファイルと同じフォルダに置いた、
config.txtというテキストファイルで行います。
  config.txtの文字コードはUTF-8で保存してください。

　PROGRAM_TITLE の行に""で括った文字列を書けば、これがプログラムタイトルに
なります。
　PROGRAM_TITLE と""の間には、一文字以上の 空白文字を置いてください。

　Interval の行では、Luaスクリプトの定義済み関数Loopの実行間隔(とタイミング
共通の、command.txtで定義したメッセージのうちキーワードINTERVALを指定した
メッセージの送出間隔単位)をミリ秒単位で指定することができます。

　DATAFOLDER の行には、セーブデータのうち、レジスタのスナップショットデータを
保存するフォルダ名を指定することができます。これはプログラムの置かれた
フォルダの上につくられるフォルダ名となります。あらかじめ同じ名前のフォルダを
作ってください。

　レジスタのスナップショットデータは、プログラム画面上方、メニューバーにある
[REGSAVE 0]というボタンを押すごとに一回づつ生成されます。
　ファイル名はDATA0.datというものになります。同名のファイルがフォルダに存在
した場合は上書きされます。メニューバーのボタンは[REGSAVE 1]と変わりますが、
この状態でボタンを押すと、その時点のレジスタの内容が、DATA1.datというファイル
に保存されます。つまり、ボタン上の番号とファイル名は対応しています。

　レジスタのスナップショットファイルは、テキストファイル形式で出力されます。
　最初にレジスタ定義ファイルでの定義レジスタ名が出力され、以降、
機器IDの若い順にレジスタ内容が出力されます。
　レジスタ内容は行先頭にアドレス(16進表記)、：で区切って以降レジスタ内の
データの並び(16進表記)となります。それぞれは,で区切られています。

　LOGFOLDER の行には、セーブデータのうち、受信ログデータを保存するフォルダ名を
指定することができます。これはプログラムの置かれたフォルダの上に
つくられるフォルダ名となります。あらかじめ同じ名前のフォルダを作ってください。

　受信ログデータのファイルは、プログラム画面上方、メニューバーにある[LOGSAVE]
というボタンを押すことで生成、保存が開始されます。保存形式はバイナリ
フォーマットです。ファイル名はLOG0.datから始まって、フォルダ内で重複の無い
ファイル名が生成され、ファイルの上書きをしません。
メニューバーの[STOP    ]を押すと保存が停止されます。

　シリアルポートの指定は、行頭から書かれた"port"という文字列の後ろに、一つ以上
の半角空白を置いて、数字で指定します。

port 1

　ボーレートの指定は、行頭から書かれた"baud"という文字列の後ろに、一つ以上の
半角空白を置いて、数字で指定します。

baud 19200

　USBシリアル変換デバイスを使用する場合、USB VID,PID及びデバイス固有シリアルを
指定することで、一致するデバイスに自動接続します。これはポート番号が変化しやすい
のに対して、特にFTDI社製デバイスのような、変化しない一貫したデバイス固有シリアル
を持つデバイスを指定して接続ができます。この機能を使う場合、portには"USB"と
指定してください。

port USB

USB_VID "0x0403"
USB_PID "0x6015"
USB_SERIAL "DK0G0GKM"

　これらパラメータはデバイスマネージャから確認できます。
　ポート(COMとLPT)->USB Serial Port(COMX)->プロパティ->詳細->デバイス インスタンス パス
  値(V)から、VID_0403 から0x0403を、PID_6015 から0x6015を、+DK0G0GKMAから
　DK0G0GKMを取り出す。


　パリティビット指定は、行頭から書かれた"parity"という文字列の後ろに、一つ以上
の半角空白を置いて、以下のキーワードを使って指定します。

parity no 		# パリティ無し
parity odd		# 奇数パリティ
parity even		# 偶数パリティ

　ストップビット指定は、行頭から書かれた"stopbits"という文字列の後ろに、一つ
以上の半角空白を置いて、以下のキーワードを使って指定します。

stopbits one		# 1ビット
stopbits onehalf	# 1.5ビット
stopbits two		# 2ビット

　制御信号コントロールの指定は、行頭から書かれた"modem"という文字列の後ろに、
一つ以上の半角空白を置いて、onかoffかで指定します。

modem on

　改行挿入の指定は、行頭から書かれた"newline"という文字列の後ろに、一つ以上の
半角空白を置いて、以下のキーワードを指定します。

newline none #送出データに改行を追加しない
newline CRLF #CRLFを追加する
newline CR   #CRを追加する
newline LF   #LFを追加する

　本プログラムは定期的にポートが開いているかチェックして、閉じたなら開きなおす
機能を有しており、この機能をON/OFF可能です。
　この機能の指定は、行頭から書かれた"Openport_mode"という文字列の後ろに、一つ
以上の半角空白を置いて、以下のキーワードを指定します。

Openport_mode startonce #通常
Openport_mode check     #定期的にポートが開いたかチェックしにゆく


　文字"#"はコメント指示です。#から行末までが、コメントとして解釈されます。

port 1 #ここはコメント
#port 2 #コメントアウト

　プログラム動作中のボーレート変更は、プログラムのメニューバの"Edit.."から行い
ます。ダイアログウィンドウが開かれますので、エディットボックスに半角数列を入れ
てOKボタンを押してください。

Display の行で、画面表示下側の表示フォーマットを変えることができます。
Display hex は、16進表示で受信データを表示します。
Display Text は、テキスト表示で受信データを表示します。
Display lua  は、表示の全てをLuaに委ねることになります。

FIXParam_Display の行で、画面表示上部の固定パラメータ表示区画の表示個数を
　無しから36個までの範囲で変えることが出来ます。
　固定パラメータ表示区画は表示2行、上行にパラメータ名、下行にパラメータの値
というペアで表示をおこないます。この2行でパラメータ1行です
　パラメータを増減した分だけ、中央の表示区画のサイズが減増します。

MEASURE_DEVICE の行で、読み込む計測器定義ファイルのファイル名を指定することが
できます。

SCRIPT の行で、読み込むLuaスクリプトのファイル名を指定することができます。
　複数のスクリプトを作って、切り替えて使う場合などに使えます。

CMD　の行で、読み込む送信データ定義ファイル名を指定することができます。

TLM　の行で、読み込むテレメトリ定義ファイル名を指定することができます。

REG　の行で、読み込むレジスタ定義ファイル名を指定することができます。


## 4:計測器定義ファイルについて。

　計測器定義ファイルに定義されたデバイスに対してLuaスクリプト上から操作する
ことができます。
　計測器定義は 行頭のキーワードDEVICEから、行頭のキーワードDEVICE_ENDの間に
の記述をひとまとめとして、キーワードDEVICEの後ろに記述されたデバイス名と
紐付けます。更にそのデバイス名の直後の on / off キーワードで、計測器定義を
有効化/無効化することができます。
　計測器の各種定義は、以下のようなキーワードを使って定義されます。
DEVICE_SETTING この直後に書かれたファイル名のファイルを読み込みます。
DEVICE_MAKER メーカ名を記載します。なくても構いません。定義済みメーカー名は
             次のようになります。 YOKOKAWA,KIKUSUI,HP,KEYSIGHT,KEISOKU,FTDI,
             OWON,MATSUSADA,TAKASAGO,ALIENTEK,DUMMY
DEVICE_TYPE  接続方法を番号で指定します。1:serial 2:IVI 3:USB HID 4:LAN 5:GPIB
			 6:FTDI BitBang 7:HID DP100
             本プログラムでは IVI,GPIB,FTDI BitBangをサポートしません。
DEVICE_DELIMITER 改行挿入の指定
                 指定のためのキーワードはConfig.txtのものと同じ
DEVICE_COMPORT シリアルポートのポート番号指定 数字、アルファベット大文字、noneの
　　　　　　　三種が指定できる。例えば DEVICE_COMPORT A とした場合、後述の
              PID,VID,デバイスシリアル番号を使用した接続をおこなう。
　　　　　　　noneとした場合はluaスクリプト内からのポート指定が優先される。
　　　　　　　この場合、PID,VID,デバイスシリアル番号を使用した接続が優先される。
DEVICE_COMBAUD 通信速度指定。DEVICE_COMPORTがnoneの場合はluaスクリプト内の
　　　　　　　速度指定が優先される。
DEVICE_VISA_ADDR 本プログラムではサポートしません。
DEVICE_LANADDR  ターゲットデバイスのIPv4アドレスを指定します。""で囲んでください。
DEVICE_LANPORT  ターゲットデバイスのポート番号を指定します。
DEVICE_GPIBPORT 本プログラムではサポートしません。
DEVICE_VID USBシリアル変換でUSBデバイスを固有識別するのに使用します。
DEVICE_PID USBシリアル変換でUSBデバイスを固有識別するのに使用します。
DEVICE_SERNUM USBシリアル変換でUSBデバイスを固有識別するのに使用します。
              ""で囲んでください。
　定義されたデバイスへはLuaスクリプトの拡張関数に、キーワードDEVICEの後ろに記述
されたデバイス名を指定することによってアクセスが可能となります。シリアルポート
番号指定でアルファベット大文字を指定した場合は、そのアルファベットで個別アクセスが
可能になります。


キーワードDEVICE_SETTING で指定したファイルでは、Luaの拡張関数DeviceSeqを用いて
利用可能な命令を定義することができます。
文法は以下の通りです。

ファイル先頭に一つ、行頭のキーワードNAMEの後ろに、デバイス名を書きます。これは
計測器定義ファイルのデバイス名と一致させる必要があります。

命令は行頭キーワードCMDの後ろに更にキーワードを付けることで、これが1行づつ発行
されることになります。これら複数行が、CMD NAME からCMD ENDで囲まれた範囲でひとつの
命令を構成します。命令は CMD NAMEで指定したコマンド名で指定が可能になります。
CMD の後ろには基本的にデバイスに送出されるメッセージを記述します。またパラメータを
3つまで、P1,P2,P3の三種を含むことが出来ます。パラメータはDeviceSeq関数の引数の
三番目以降に記述することができます。
CMD SLEEPは記述タイミングで指定秒スリープが入ります。
CMD MWAITは記述タイミングで指定ミリ秒スリープが入ります。
CMD VOLT、CMD STOP、CMD INFO、CMD ACT、CMD READはDP100固有命令です。
行頭キーワードINITは、ファイル内で一つだけ、初期化に用いる命令構成を定義するために
使います。INITはCMDと同じように記述します。


## 5:送信データ定義ファイルについて。

　決められた書式で記述された送信データファイルを用意しておくことで、様々なデータ
送信を行うことができます。

　書式は以下の通り

SEND 0x55 0xaa 65000 0b01010011 CRC "hoge" INTERVAL 10 LABEL "ほげ"

　行頭に"SEND"という文字があると、その行は送信データとして解釈されます。以降
改行まで、送信データとして解釈された記述はひとかたまりとして保持され、同時に
送信されます。
　SENDの文字の後ろには半角スペース一つ以上の空白が必要です。タブでも構いません
が、全角空白は使用できません。以降も、データの区切りとして空白が使用されます。

　記述として合法な定義は以下のようなものがあります。

1：1バイト単位の16進表記　最初に0xがつくと16進表記として解釈されます。
2：1バイト単位の2進表記　最初に0bがつくと2進表記として解釈されます。
3：1～4バイトまでの10進表記
4：文字列　"で囲まれた文字列が有効です"

　キーワードINTERVALは、送信データ列を以降定期的に送出することの宣言です。送出
間隔はキーワードの後ろの数字で指定します。単位は秒です。

　キーワードLABELは、ツールバーのSENDプルダウンメニュー中の表記を、LABELで
示された記述にすることができます。LABELが無い場合、プルダウンメニューの内容は、
送信データを16進数に直したものとなりますが、LABELはこれを置き換えます。
コメントには日本語(UTF-8)も使用可能です。

　キーワードCRCは、これを2バイトのCCITT-16 CRCと置換して送信データ列に挿入し
ます。バイト順は下位、上位の並びになります。

　文字"#"はコメント指示です。#から行末までが、コメントとして解釈されます。
コメントには日本語(UTF-8)も使用可能です。

　これら有効な送信データ定義が存在した場合、プログラムのメニューバーに"SEND"と
いうメニューが登場します。ここからサブメニューで、送信したいデータを選ぶ
ことで、送信が可能になります。
　なお、サブメニューでは、データは全て16進で表示されます。

　本プログラムは、別のさまざまな送信データ定義ファイルを読み込むこともでき
ます。
　メニューバのSENDメニュー以下のサブメニューの最後に、"ReadCMDFile"という
メニューが存在します。これを選択することで、他のファイルを選択することができます。


## 6:テレメトリ定義ファイルについて。

　テレメトリ定義ファイルは、テレメトリ各項目の定義の集合体となっています。各項目へは
拡張関数mkframeに渡すパラメータ配列の先頭からの順番と対応しています。各項目には1から
始まる連番をコメントで付与することを推奨します。
各項目の定義は、キーワードTLMを先頭として次に項目名で区別し、括弧{}で囲った内容で
定義される。{}の中には、キーワードTYPEに記述する項目タイプと、キーワードPARTで
記述する要素を含む。PART要素は複数含むことがある。
PART要素は{}の中に、キーワードMAJOR,MINOR,MASK,SHIFTで記述する内容を含む。
キーワードMAJORは、固定長テレメトリフレームの先頭からの位置を指定する。これはバイト単位である。
キーワードMINORは、マイナーフレーム指定時のマイナーフレーム番号を指定する。マイナーフレームは16フレームを想定しているが、16フレーム以下なら対応する。
　　　マイナーフレームを採用していない場合は、全ビット1を立てておくことを推奨する。
キーワードMASKは、パラメータ配列からデータを取り出し格納する際の有効ビット範囲を示す。
      これは次の項目SHIFTを組み合わせると理解しやすい。例えば1ビットのフラグを、1ビット
	  づつテレメトリに格納するとする。
　　　元のフラグ変数は0か1か、これをSHIFTの指示でテレメトリの格納位置まで移動させて、
　　　MASKを使って他の値が入らないようにして論理AND演算で値を格納する。
　　　例として、テレメトリ上のあるバイト位置の指定ビットに値を入れる場合：
　　　A |= (flag_1bit << SHIFT) & MASK
キーワードSHIFTは、パラメータ配列の値をビットシフトする量を指定します。
PART要素は一つにつき最大8bitまでのテレメトリ格納を記述する。例えば元のデータが32bit
あった場合、4つのPART要素が必要となる。
PART要素、TYPE要素は、字下げして記述することを推奨する。

　項目TYPEで使用するキーワードはファイル先頭にまとめて記述することを推奨する。
フォーマットは以下の通り：
キーワードDEF,空白,キーワード名,空白,値(実数)
例：
DEF SYS 0

#から後ろ、行末までコメントアウトとなる。


## 7:レジスタ定義ファイルについて。

　8.4で詳しく説明します。


## 8:Luaスクリプト設定

###8.1:簡単な使い方

####8.1.1:使えるシリアルポートの番号を調べて、script.luaの中の
	SerialInit(0,10,115200)
 　と書いてある部分(104行目あたり)の、SerialInit(0,"この部分",115200)を
　 調べた番号に書き換えてください。
例：SerialInit(0,3,115200)
例：SerialInit(0,A,115200)

   既にポートが開かれている場合は改めてポートが開かれることはありません。
スクリプトが別のポートを開こうとして存在しないポートを指定した場合は
ポートを開くのに失敗したままとなります。

####8.1.2:プログラムを起動して、画面にInit OKと出ているのが確認できたならば
　 ちゃんと動いています。

####8.1.3:画面上のツールバー、[LOGSAVE]を押すと、シリアルポートから受信した
    データ、例えばコマンドなどがファイルに記録されます。
　　ファイルはLOGというフォルダ内につくられます。

####8.1.4:画面上のツールバー、[REGSAVE 0]を押すと、内部に仮想的に持っている
　　機器レジスタの状態をファイルに出力します。ファイルはボタンを押す
　　たびに作られます。
　　ファイル名は DATA0.datという感じに番号が付いて、この番号はファイルを
　　作るたびに自動的に増えていきます。

####8.1.5:コマンドを受信すると、画面に受信した値が16進数で表示されます。
　　コマンドでレジスタが書き換わったか、レジスタ状態を適示保存して
　　確認してください。

###8.2:lua言語について

　Lua言語は軽量で組み込みに適したスクリプト言語です。
　サイトURLを以下に示します。
https://www.lua.org/
　以下のサイトなどが文法解説などまとまっている。
https://ie.u-ryukyu.ac.jp/~e085739/lua.hajime.html
　使用したバージョンは5.4.1です。

###8.3:Lua言語の拡張について

このLua処理系は以下のように独自拡張されています。

A:以下の関数が追加されています。
DispStrP()
 引数無し、戻り値無し。先にグローバル変数Dispstr,Displenにテキストとその
文字列長を入れて呼び出すと、画面にテキストが表示される。
　例：
	Dispstr = "Init OK"
	Displen = 7
	DispStrP( )

DispParamlP(ch,Label, Data)
 引数:ch 表示位置 ,Label 文字列, Data 整数 戻り値は特になし。
 画面の上部固定位置にラベル文字列とデータ(整数値)の二段でテキストが表示される。
 パラメータの表示などに用いることを想定している。データは10進表示となる。
　固定表示位置は　横に4つ、3段の計12種類の表示となる。従ってchの値は0～11と
なる。
　例：
	DispParamlP(0,"Count",count)
	count = count + 1

　但し、全12chが表示されるのはFIXParam_Displayに12を指定した時のみとなる。
FIXParam_Displayが0の場合は関数実行によっても表示は全ておこなわれない。

DispParamfP(ch,Label, Data)
 引数:ch 表示位置 ,Label 文字列, Data 浮動小数点数 戻り値は特になし。
 画面の上部固定位置にラベル文字列とデータ(小数点値)の二段でテキストが
表示される。
 パラメータの表示などに用いることを想定している。データは10進表示となる。
　固定表示位置は　横に4つ、3段の計12種類の表示となる。従ってchの値は0～11と
なる。
　但し、全12chが表示されるのはFIXParam_Displayに12を指定した時のみとなる。
FIXParam_Displayが0の場合は関数実行によっても表示は全ておこなわれない。


rtn = SerialInit(ch,port,baud)

 引数:ch シリアルポート定義番号、0から9まで指定可能。
　　　port シリアルポートの番号、これに数字以外のA～Jまでのアルファベットを
　　指定した場合、device_config.txtで定義したVID,PID,シリアルの特徴を持つ接続済み
　　シリアルポートを探し、Openします。これで特定機器への確実な接続が期待できます。
　　　device_config.txtで定義したデバイス名で指定することもできます。
　　  baud ビットレート 戻り値 0で成功、1で失敗。データ長、パリティ、ストップビット
　　などは8,N,1固定となります。
　  シリアルポートの初期化はLuaスクリプト内でおこないます。
　例：
	SerialInit(0,10,115200)
  or
	SerialInit(0,A,115200)
  or
	SerialInit(0,"Insulation_Serial_1",115200)

　アルファベット大文字、あるいはデバイス名はシリアルポート定義番号とここで紐づけられ
　以降はシリアルポート定義番号を使っていきます。


SerialSend(ch, Buffer, len)
 引数:ch シリアルポートを開いたときのch番号、このプログラムでは0固定
        Buffer 送信文字列(バイナリでも問題なく出力できます) len 文字数
        シリアルポート送信のための関数です。
　例：
	Send = string.format("%x \n",Count)
	SerialSend(0,Send,string.len(Send))

rtn = SerialWaitRecv(ch,Timeout)
 引数:ch シリアルポートを開いたときのch番号、このプログラムでは0固定
        Timeout ここに指定した整数秒、受信を待つ。
        戻り値: 0で受信、1でタイムアウト
　　この関数は受信イベントをただ待つ、処理を止めておくためだけの関数であり、
　　どんなものを受信したかは、別途SerialRecv()関数を呼び出さなくてはならない。

len,Buf = SerialRecv(ch,Buf)
 引数:ch シリアルポートを開いたときのch番号、このプログラムでは0固定
        Buf 受信文字列(中身があっても受信文字列で上書きされます) len 受信文字数
        シリアルポート受信のための関数です。
　例：
	len,Buf = SerialRecv(0,Buf)
	if(len > 0) then

Buf,len = SerialRecv2(ch)
 引数:ch シリアルポート定義番号、0から9まで指定可能。SerialInit時に指定したものです。
        Buf 受信文字列(luaストリングでここで定義されます) len 受信文字数
　例：
	Buf,len = SerialRecv(0)
　Bufは関数内で生成されて使用後にガベージコレクションされます。
　基本的にSerialRecv2の使用を推奨する。

rtn = HIDSend(ch,Buf,len)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 送信文字列 len 文字数　Bufferは0を含むバイナリを送信可能である

rtn = HIDSendS(ch,Buf)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 送信文字列 送信文字列が途中に0を含まない文字列の場合これが使える

rtn = HIDSendS3(ch,Buf)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 送信文字列 送信文字列が途中に0を含まない文字列の場合これが使える

len,Buf = HIDRecv(ch,Buffer,len)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 受信文字列 len 文字数　Bufferは0を含むバイナリを受信可能である

len,Buf = HIDRecv2(ch,Buffer,len)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 受信文字列 len 文字数　Bufferは0を含むバイナリを受信可能である

len,Buf = HIDRecv3(ch,Buffer,len)
 引数:ch MDEV計測器定義で指定可能。ただこれを直接指定するのは難しいため
　　　　機器名で指定することを推奨する。
        Buffer 受信文字列 len 文字数　Bufferは0を含むバイナリを受信可能である

rtn = NetInitCheck(ch)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
 戻り値:1で初期化済み、0:で未初期化

rtn = NetConnect(ch)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
 戻り値:1で接続済み、0:で未接続

rtn = NetDisConnect(ch)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
 戻り値:常に0

rtn = NetSend(ch,Buf,len)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
      Buf 送信文字列 lan 送信文字数
 戻り値:1で送信成功、0:で送信失敗

rtn = NetWaitRecv(ch,timeout)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
      timeout 受信待ち timeout秒またはデータ受信まで待つ
 戻り値:1でタイムアウト、0で受信

len,Buf = NetRecv(ch,Buf)
 引数:ch LAN接続計測器定義、0から4で指定可能。機器名でも指定できます。
      Buf 受信文字列 
 戻り値 len:受信文字数、Buf:受信文字列

Sleep(wait)
 引数:wait 指定整数秒処理を停止して待機する。
　例：
	Sleep(10)

uSleep(wait)
 引数:wait 指定整数マイクロ秒処理を停止して待機する。
　例：
	uSleep(10)

mSleep(wait)
 引数:wait 指定整数ミリ秒処理を停止して待機する。
　例：
	mSleep(10)

Data = RegRead(RID,addr)
 引数:RID 領域種別 addr レジスタアドレス 戻り値：レジスタ中の値
 設定ファイルReg.txtで定義されたレジスタをアクセスするための関数です。
　例：
	Send = string.char(MID,RegRead(0,ADDR),0,0,0,0,0,0,0,0,0,0,0)
　　この例では直接テレメトリ文字列を生成している。
　領域種別は領域種別定義順に0から並べた位置、または領域REGION要素名の
文字列で指定することができます。
    Data = RegRead("MAIN_MEM",Addr)
　引数addrは数字しか指定できません。アドレスを文字列でアクセスするなら、
Luaのテーブルを使用してください。
  例：
DefAddr ={
	"CONTROL_REG" = 0x0100
	"STATUS_REG"  = 0x0104
}
    Data = RegRead("REG_AREA","STATUS_REG")


RegWrite(RID,addr,Data)
 引数:RID 領域種別 addr レジスタアドレス Data レジスタに書き込む値
 設定ファイルReg.txtで定義されたレジスタをアクセスするための関数です。
　例：
	RegWrite(0,RADDR,string.byte(Buf,4,4))
      コマンド文字列から書き込む値を直接取り出して書いている
　領域種別は領域種別定義順に0から並べた位置、または領域REGION要素名の
文字列で指定することができます。
    RegWrite("MAIN_MEM",Addr,Data)
　引数addrは数字しか指定できません。アドレスを文字列でアクセスするなら、
Luaのテーブルを使用してください。

CRC = CRC16(BUF,len)
  引数：コマンド/テレメトリバッファ 後ろ2バイト(len-2)は0にされた上でCRCが挿入される
　戻り値:CRC unsigned short値
  PCDU 8byteコマンドならlen=8、テレメトリならlen=385。

mkframe()
　引数:1 テレメトリバイナリ格納用の文字列バッファ。 
      :2 バッファサイズ
      :3 テレメトリ値を持っているLuaテーブル
  戻り値: テレメトリバイナリ格納用の文字列バッファ。引数1そのもの
　固定長フォーマットのテレメトリバイナリを生成する。フォーマットはconfig.txtで定義した
テレメトリ定義ファイルで定義する。定義名が無い場合はtlm.txtを探す。


rtn = DeviceSeq("デバイス名","シーケンス名",param...)
　引数:"デバイス名":device_config.txtで定義したデバイス名称
       "シーケンス名":device_config.txtで定義した設定パターンファイルで定義された
　　　　シーケンス名称。
　　　 param:シーケンスはパラメーターを取ることがあり、ここに書いた値を使用する
　戻り値:0:失敗 1:成功
例:
 DeviceSeq("SPE6102_1","SETV",param1)

KeyWait()
　引数:無し
　戻り値:無し
 Lua実行を一時停止し、特定のキー入力(リターン）待ち状態にする
 本体タイマーイベントで毎回Lua内のLoop関数を呼び出して実行しているが、これを停止する。

SetC("変数名",flg,Value)
 LMクラスに登録した変数に値をセットする
 引数1:変数名 2:種別 3:値
 これでLuaスクリプト内からC++に値を渡す
 変数名はレジスタ定義ファイル内にDEFキーワードの後ろに書いて定義する
 種別:0 整数 1:浮動小数点数


Value = GetC("変数名",flg)
 LMクラスに登録した変数から値を取り出す
 引数1:変数名 2:種別
 変数名はレジスタ定義ファイル内にDEFキーワードの後ろに書いて定義する
 種別:0 整数 1:浮動小数点数
　戻り値:数値、整数か浮動小数点数かは引数:2で決める



B:以下の関数の動作が決め打ちされています
function Startup()
 引数無し、戻り値無し
 プログラム起動時に一度だけ呼び出されます。Arduinoのものと同じだと思って
ください。

function Loop()
 Config.txtのInterval に指定したミリ秒(初期値は 1000)の間隔を置いて
呼び出します。
　Arduinoのものと同じだと思ってください。

### 8.4:レジスタ定義ファイルについて

　レジスタ定義ファイルのフォーマットですが、REGION_MAIN に続いてレジスタ種別名
を指定できます。

例: REGION REG {

　REGION要素には名前を付けることができ、その内容は{}の中に記述されます。
  REGION要素は領域種別として定義順に0から番号でアクセスが可能です。
　REGION要素は指定開始アドレスSTARTから終了アドレスDNDまでのメモリ空間を
持ちます。この内容にはアドレス指定で内容に1ワード16bit単位でアクセスできます。
 開始アドレスと終了アドレスの間であれば指定アドレスへのアクセスは正常に
おこなわれます。
　メモリ空間は0で初期化されます。

RegRead()関数やRegWrite()関数では、リージョン領域種別とアドレスを指定する
ことでこれらレジスタにアクセス可能です。

　例えば撮像トリガコマンドを作りたかったら、レジスタ定義ファイルに独自の
レジスタを定義して、これに書き込むことで撮像トリガとする、みたいな応用が
できるでしょう。
　Luaスクリプトで、この独自レジスタを毎秒監視して、書き込まれたら動作する
ようなスクリプトが書けるでしょう。


### 8.5：添付サンプルプログラムについて

添付のLuaスクリプト script.luaは典型的なシリアルデバイスの動作を模擬します。

まず、Startup()関数で、レジスタ初期値の設定が行われます。
　シリアルポートの初期化が成功すると、画面にInit OKと表示されます。

Loop()関数は、シリアルポートからの入力を受け付け、これをコマンドとして
解釈して、リードレジスタが立っていた場合、テレメトリを返します。
またコマンドに従ってレジスタに値を書き込みます。


## 9:表示

　プログラムは固定画面サイズで、3つの区画に分けて表示をおこなます。
　一番上には、横に4つ、縦に最大3つの固定パラメータ表示区画をつくることが
できます。ここはLuaスクリプトで定義、表示可能な区画で、パラメータのラベル、
値の整数及び浮動小数点数表示が可能です。
　ここの表示区画数はconfig.txtのFIXParam_Displayパラメータによって変更
可能です。
　真ん中は受信データ表示区画で、config.txtで表示を16進表示とテキスト表示
を切り替えることができます。これはプログラム動作中に変更できません。また
Luaスクリプトは自由にテキスト表示をおこなえます。Luaで16進表示を行いたい
ときはプログラムで出力を加工してください。
　16進表示では右端にasciiキャラクタでの表示も同時におこないます。ascii
キャラクタにならないものは*で置換されます。
　一番下6行は送信データ表示区画で、16進表示されます。


## 10:起動後設定

　起動後にポート及びボーレートの設定が変更可能です。
　もしConfig.txtで定義されたportが存在しなかった場合、Portを開けなかった旨の
ダイアログを表示して起動します。PortはCOMXと表示されPort接続していない状態
です。
　もし他に接続可能なPortがある場合、COMXをクリックすると選択可能なportが
プルダウンで表示され、選ぶことが出来ます。
　また、COM3など既に接続している場合でも、これをクリックすると選択可能なportの
リストが現れ、選択、変更が可能となります。
　"Baud..."からダイアログを開いて、ボーレートの変更が可能です。

## 11:受信
　プログラムは起動時に設定されたシリアルポートを開こうとします。開けない場合は
メッセージを出します。プログラムは起動しますが、動作しませんので、終了して、
正しい設定を行ってください。
　エラーメッセージ無しでプログラムが起動した場合、既にポートは開かれ受信状態に
あります。プログラム起動中にポートを閉じることはできません。
　要するに、正しく設定されていればほぼオペレーションフリーです。


## 12:送信

　これはプログラムのメニューバの"CMD.."から行います。ダイアログウィンドウが
開かれ、そこに二つのエディットボックスに、それぞれターゲットボードのI/O
アドレスと、Write動作の際に書き込みたいデータを書き込み、"WRITE"もしくは
"READ"ボタンを押します。

　この正常な動作にはターゲットボード側ソフトウェアの対応が必要です。
　ターゲットボードに期待される動作は、指定したアドレスに指定したデータを書き
込む、または指定したアドレスのデータを1バイト読んで、シリアルポート経由で
bincomに送り返す、というものです。

　送信されるコマンドは4バイト、コマンドフォーマットは以下の通りです

位置(バイト) 意味			値
0		コマンドタイプ	動作タイプ指示　0=Write 1=Read
1		アドレス		ターゲットボードのI/Oアドレス指示
2		データ			Write動作時の書き込みデータ指示
3		コマンドエンド	常に0x00

　コマンドタイプに Readを指定した場合、2バイト目のデータ指示は無視されます。

　エディットボックスに書き込む値は、頭に"0x"と付けると16進文字列と、"0b"とつく
と2進文字列として解釈します。半角数字列だけだと10進とみなします。
　もし他のアルファベットなどが混入した場合、送信データはデフォルト定義のものが
使用されます。


## 13:記録

　プログラムのメニューバの"SAVE"をクリックすると受信データが、プログラムバイ
ナリと同じフォルダに保存されます。同時にメニューバー文字列は"NowSaving.."と
変化します。
　この間に受信したデータはすべてファイルに保存されます。"NowSaving.."の文字列
をクリックすると、データ保存は終了します。
　保存ファイルのファイル名には自動的に、連番のファイル名が振られます。ファイル
先頭には記録開始時間が、末尾には記録終了時間が記録されます。
　ファイル名は重複しないようになっています。

　プログラムのメニューバーの"CMD.."を選択し、プルダウンメニューの下部、
"SaveSendData"を選択すると、以降再びこの項目を選択するまで送信データが固定ファ
イル名"SENDDATA.DAT"に保存されます。
　保存中はメニューの項目は"NowSaving.."に変化します。


## Licence
## 14:ライセンスについて
　適用されるライセンスはありません。
　配布の際には、2:に示した構成で行ってください。
　改変の際は、程度に応じて著作権者表記を変更してください。

## 15:コンパイル

　プログラムはVisual Studio 2022 C++で、x64 Releaseコンパイルされています。
　添付ソースからコンパイルする際は、まずLuaソースコードからコンパイルし、
LibLua.libファイルを作成してください。Luaソースコードは添付ソースのフォルダに
作成したluaフォルダに展開してください。
　luaソースコードはhttps://www.lua.org/download.htmlからダウンロードしてください。
  本プログラムのビルドにはlibUSBのインストールとそのライブラリが必要です。libusb.hと
libusb-1.0.libを本ソースと同じフォルダにコピーしてから、プロジェクトをビルド
してください。

## 16:既知の不具合
　現在は特に報告されていません。お気づきの箇所がありましたら、
以下の連絡先までご連絡ください。

## Author 
## 17:著作権者及び連絡先
Mizuki Tohru
[twitter](https://twitter.com/mizuki_tohru)

